# Parallel Quicksort
Для работы алгоритма сортировки были реализованы функции `parallel_map`, `parallel_scan`, `parallel_filter` используя `cilk_for` как основной инструмент распараллеливания.

Алгоритмы сортировки представлены в виде функций `parallel_qsort_filter` и `parallel_qsort_inplace`:
* `parallel_qsort_filter` основан на примитивах параллелизации, представленных выше
* `parallel_qsort_inplace` использует конструкцию fork-join для расспараллеливания рекуррентных вызовов; дополнительно имеет перегрузку на размер блока `block_size`, для которого сортировка будет выполняться последовательно

# Тестирование
В папке `tests` находятся файлы для тестирования реализованных функций.
Бенчмаркинг функций проводился на 4 рабочих потоках, используя на массивы случайных чисел размера 10^8.

# Результаты
Работа `parallel_tools` функций ( среднее по 5 запускам; время работы измеряется в милисекундах) 

sequentional_map - 564
parallel_map  - 205
ускорение: 2,7512

sequentional_scan - 54 
parallel_scan - 484 
ускорение: 0,1116


sequentional_filter - 749
parallel_filter - 1043 
ускорение: 0,7181

Заметим, что использование параллельных функций ухудшает время работы; это обусловлено тем, что на 4 потоках они не могут дать достаточное ускорение от параллельности. Хоть данные версии и имеют логарифмический Span, для синхронизации потоков и данных требуется несколько проходов `cilk_for`, что даёт больше работы ядрам и нивелирует положительный эффект. Для `sequentional_scan` это особенно заметно из-за его inplace реализации - в последовательной функци даже не нужно создавать внутри себя дополнительные объекты для работы.

Работа функций сортировки:

 sequential_qsort - 42074 
 

 parallel_qsort_filter - 268839 
 
ускорение: 0,1565


 parallel_qsort_inplace - 14968 
 
ускорение: 2,8109


parallel_qsort_inplace c блоками последовательной сортировки:
| Размер блока | Результат работы | Ускорение |
| --- | --- | --- |
| 10 | 14792 | 2,8443 |
| 100 | 14619 | 2,8780 |
| 1000 | 15334 | 2,7438 |
| 10000 | 15304 | 2,7492 |
| 100000 | 14722 | 2,8578 |
| 1000000 | 14727 | 2,8569 |


Аналогично с предыдущему случаю, распараллеливание через filter не даёт ускорения - за полилогарифмический Span алгоритму `parallel_qsort_filter` приходится пройти несколько `cilk_for` по данным в процессе работы `parallel_filter`.
`parallel_qsort_inplace` имеет линейный Span из-за `partition` функции внутри, но благодаря fork-join у него получается использовать все 4 потока практически не добавляя лишней работы в алгоритм. Inplace реализация тоже позволяет сэкономить время на создании дополнительных массивов во время работы.
